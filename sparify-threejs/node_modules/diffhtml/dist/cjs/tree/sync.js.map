{"version":3,"sources":["../../../lib/tree/sync.js"],"names":[],"mappings":"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","file":"sync.js","sourcesContent":["const slice = Array.prototype.slice;\nconst filter = Array.prototype.filter;\n\n// Patch actions.\nexport const REMOVE_ELEMENT_CHILDREN = -2;\nexport const REMOVE_ENTIRE_ELEMENT = -1;\nexport const REPLACE_ENTIRE_ELEMENT = 0;\nexport const MODIFY_ELEMENT = 1;\nexport const MODIFY_ATTRIBUTE = 2;\nexport const CHANGE_TEXT = 3;\n\n/**\n * Synchronizes changes from the newTree into the oldTree.\n *\n * @param oldTree\n * @param newTree\n * @param patches - optional\n */\nexport default function sync(oldTree, newTree, patches) {\n  patches = patches || [];\n\n  if (!Array.isArray(patches)) {\n    throw new Error('Missing Array to sync patches into');\n  }\n\n  if (!oldTree) {\n    throw new Error('Missing existing tree to sync');\n  }\n\n  const oldNodeValue = oldTree.nodeValue;\n  const oldChildNodes = oldTree.childNodes;\n  const oldIsTextNode = oldTree.nodeName === '#text';\n\n  // TODO Make this static...\n  var oldChildNodesLength = oldChildNodes ? oldChildNodes.length : 0;\n\n  if (!newTree) {\n    const removed = [oldTree].concat(\n      oldChildNodes.splice(0, oldChildNodesLength)\n    );\n\n    patches.push({\n      __do__: REMOVE_ENTIRE_ELEMENT,\n      element: oldTree,\n      toRemove: removed\n    });\n\n    return patches;\n  }\n\n  const nodeValue = newTree.nodeValue;\n  const childNodes = newTree.childNodes;\n  const childNodesLength = childNodes ? childNodes.length : 0;\n  const nodeName = newTree.nodeName;\n  const attributes = newTree.attributes;\n  const newIsTextNode = nodeName === '#text';\n  const newIsFragment = newTree.nodeName === '#document-fragment';\n\n  // Replace the key attributes.\n  oldTree.key = newTree.key;\n\n  // If the element we're replacing is totally different from the previous\n  // replace the entire element, don't bother investigating children.\n  if (oldTree.nodeName !== newTree.nodeName) {\n    patches.push({\n      __do__: REPLACE_ENTIRE_ELEMENT,\n      old: oldTree,\n      new: newTree\n    });\n\n    return patches;\n  }\n  // This element never changes.\n  else if (oldTree === newTree) {\n    return patches;\n  }\n\n  const areTextNodes = oldIsTextNode && newIsTextNode;\n\n  // If the top level nodeValue has changed we should reflect it.\n  if (areTextNodes && oldNodeValue !== nodeValue) {\n    patches.push({\n      __do__: CHANGE_TEXT,\n      element: oldTree,\n      value: newTree.nodeValue\n    });\n\n    oldTree.nodeValue = newTree.nodeValue;\n\n    return patches;\n  }\n\n  // Ensure keys exist for all the old & new elements.\n  const noOldKeys = !oldChildNodes.some(oldChildNode => oldChildNode.key);\n  var newKeys = null;\n  var oldKeys = null;\n\n  if (!noOldKeys) {\n    newKeys = new Set(\n      childNodes\n        .map(childNode => String(childNode.key))\n        .filter(Boolean)\n    );\n\n    oldKeys = new Set(\n      oldChildNodes\n        .map(childNode => String(childNode.key))\n        .filter(Boolean)\n    );\n  }\n\n  // Most common additive elements.\n  if (childNodesLength > oldChildNodesLength) {\n    // Store elements in a DocumentFragment to increase performance and be\n    // generally simplier to work with.\n    const fragment = [];\n\n    for (let i = oldChildNodesLength; i < childNodesLength; i++) {\n      // Internally add to the tree.\n      oldChildNodes.push(childNodes[i]);\n\n      // Add to the document fragment.\n      fragment.push(childNodes[i]);\n    }\n\n    oldChildNodesLength = oldChildNodes.length;\n\n    // Assign the fragment to the patches to be injected.\n    patches.push({\n      __do__: MODIFY_ELEMENT,\n      element: oldTree,\n      fragment: fragment\n    });\n  }\n\n  // Remove these elements.\n  if (oldChildNodesLength > childNodesLength) {\n    // For now just splice out the end items.\n    const diff = oldChildNodesLength - childNodesLength;\n    let toRemove = [];\n    const shallowClone = [...oldChildNodes];\n\n    // There needs to be keys to diff, if not, there's no point in checking.\n    if (noOldKeys) {\n      toRemove = oldChildNodes.splice(oldChildNodesLength - diff, diff);\n    }\n    // This is an expensive operation so we do the above check to ensure that a\n    // key was specified.\n    else {\n      const keysToRemove = new Set();\n\n      // Find the keys in the sets to remove.\n      oldKeys.forEach(key => {\n        if (!newKeys.has(key)) {\n          keysToRemove.add(key);\n        }\n      });\n\n      // If the original childNodes contain a key attribute, use this to\n      // compare over the naive method below.\n      shallowClone.forEach((oldChildNode, i) => {\n        if (toRemove.length >= diff) {\n          return;\n        }\n        else if (keysToRemove.has(oldChildNode.key)) {\n          const nextChild = oldChildNodes[i + 1];\n          const nextIsTextNode = nextChild && nextChild.nodeType === 3;\n          let count = 1;\n\n          // Always remove whitespace in between the elements.\n          if (nextIsTextNode && (toRemove.length + 2) <= diff) {\n            count = 2;\n          }\n          // All siblings must contain a key attribute if they exist.\n          else if (nextChild && nextChild.nodeType === 1 && !nextChild.key) {\n            throw new Error(`\n              All element siblings must consistently contain key attributes.\n            `.trim());\n          }\n\n          // Find the index position from the original array.\n          const indexPos = oldChildNodes.indexOf(oldChildNode);\n\n          // Find all the items to remove.\n          toRemove.push.apply(toRemove, oldChildNodes.splice(indexPos, count));\n        }\n      });\n    }\n\n    // Ensure we don't remove too many elements by accident;\n    toRemove.length = diff;\n\n    // Ensure our internal length check is matched.\n    oldChildNodesLength = oldChildNodes.length;\n\n    if (childNodesLength === 0) {\n      patches.push({\n        __do__: REMOVE_ELEMENT_CHILDREN,\n        element: oldTree,\n        toRemove\n      });\n    }\n    else {\n      // Remove the element, this happens before the splice so that we still\n      // have access to the element.\n      toRemove.forEach(old => patches.push({\n        __do__: MODIFY_ELEMENT,\n        old\n      }));\n    }\n  }\n\n  // Replace elements if they are different.\n  if (oldChildNodesLength >= childNodesLength) {\n    for (let i = 0; i < childNodesLength; i++) {\n      if (oldChildNodes[i].nodeName !== childNodes[i].nodeName) {\n        // Add to the patches.\n        patches.push({\n          __do__: MODIFY_ELEMENT,\n          old: oldChildNodes[i],\n          new: childNodes[i]\n        });\n\n        // Replace the internal tree's point of view of this element.\n        oldChildNodes[i] = childNodes[i];\n      }\n      else {\n        sync(oldChildNodes[i], childNodes[i], patches);\n      }\n    }\n  }\n\n  // Attributes are significantly easier than elements and we ignore checking\n  // them on fragments. The algorithm is the same as elements, check for\n  // additions/removals based off length, and then iterate once to make\n  // adjustments.\n  if (!newIsFragment && attributes) {\n    // Cache the lengths for performance and readability.\n    const oldLength = oldTree.attributes.length;\n    const newLength = attributes.length;\n\n    // Construct a single patch for the entire changeset.\n    const patch = {\n      __do__: MODIFY_ATTRIBUTE,\n      element: oldTree,\n      attributes: [],\n    };\n\n    // Find additions.\n    if (newLength > oldLength) {\n      for (let i = oldLength; i < newLength; i++) {\n        const oldAttr = oldTree.attributes[i];\n        const newAttr = attributes[i];\n\n        patch.attributes.push({ oldAttr, newAttr, });\n        oldTree.attributes.push(newAttr);\n      }\n    }\n\n    // Find removals.\n    if (oldLength > newLength) {\n      for (let i = newLength; i < oldLength; i++) {\n        const oldAttr = oldTree.attributes[i];\n        const newAttr = attributes[i];\n\n        patch.attributes.push({ oldAttr, newAttr, });\n      }\n\n      // Reset the internal attributes to be less.\n      oldTree.attributes = oldTree.attributes.slice(0, newLength);\n    }\n\n    // Find changes.\n    for (let i = 0; i < attributes.length; i++) {\n      const oldAttr = oldTree.attributes[i];\n      const newAttr = attributes[i];\n      const oldAttrName = oldAttr ? oldAttr.name : undefined;\n      const oldAttrValue = oldAttr ? oldAttr.value : undefined;\n      const newAttrName = newAttr ? newAttr.name : undefined;\n      const newAttrValue = newAttr ? newAttr.value : undefined;\n\n      // Only push in a change if the attribute or value changes.\n      if (oldAttrValue !== newAttrValue) {\n        // Add the attribute items to add and remove.\n        patch.attributes.push({\n          oldAttr,\n          newAttr,\n        });\n\n        oldTree.attributes[i] = newAttr;\n      }\n    }\n\n    // Add the attribute changes patch to the series of patches, unless there\n    // are no attributes to change.\n    if (patch.attributes.length) {\n      patches.push(patch);\n    }\n  }\n\n  return patches;\n}\n"]}