'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = makeNode;

var _helpers = require('./helpers');

var _pools = require('../util/pools');

var _cache = require('../util/cache');

/**
 * Converts a DOM Node into a Virtual Tree Element.
 *
 * @param {Object} node - A DOM Node
 * @return {Object} - A Virtual Tree Element
 */
function makeNode(node) {
  // These are the only DOM Node properties we care about.
  var nodeName = node.nodeName.toLowerCase();
  var nodeType = node.nodeType;
  var nodeValue = node.nodeValue;
  var attributes = node.attributes || [];
  var childNodes = node.childNodes || [];

  // We ignore any DOM Node that isn't an: Element, Text, Document Fragment, or
  // Shadow Root.
  if (nodeType !== 1 && nodeType !== 3 && nodeType !== 11) {
    return false;
  }

  // We can consider either of these DOM Nodes as Text Nodes.
  var isTextNode = nodeName === '#text' || nodeName === 'text';

  // In the case of Text Node's we can have the createElement function set
  // the nodeValue for us.
  var initialValue = isTextNode ? nodeValue : [];

  // Creates a Virtual Tree Element based off this nodeName. We aren't going
  // to set the attributes right away since we want to set the key on the vTree
  // and push directly into the pre-existing array.
  var vTree = (0, _helpers.createElement)(node.nodeName, [], initialValue);

  // Creates Virtual Tree Attributes for each attribute in the DOM Node.
  for (var i = 0; i < attributes.length; i++) {
    var attr = (0, _helpers.createAttribute)(attributes[i].name, attributes[i].value);

    // If the `key` attribute is found, set the respective value on the vTree.
    if (attr.name === 'key') {
      vTree.key = attr.value;
    }

    vTree.attributes.push(attr);
  }

  // Associate this newly allocated vTree with this DOM Node.
  _cache.NodeCache.set(vTree, node);

  // If the element has child nodes, convert them all to virtual nodes.
  for (var _i = 0; _i < childNodes.length; _i++) {
    var newNode = makeNode(childNodes[_i]);

    // We may get a falsy value back if we pass in a Comment Node or other
    // DOM Nodes that we intentionally ignore.
    if (newNode) {
      vTree.childNodes.push(newNode);
    }
  }

  // Prune out whitespace/everything from between tags nested under the HTML
  // tag, since this behavior can be observed in browsers and specification.
  if (vTree.nodeName === 'html') {
    vTree.childNodes = vTree.childNodes.filter(function (childNode) {
      return childNode.nodeName === 'head' || childNode.nodeName === 'body';
    });
  }

  return vTree;
}
//# sourceMappingURL=make.js.map