{"version":3,"sources":["../../../lib/node/transaction.js"],"names":[],"mappings":"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","file":"transaction.js","sourcesContent":["import patchNode from './patch';\nimport getFinalizeCallback from './finalize';\nimport makeTree from '../tree/make';\nimport syncTree from '../tree/sync';\nimport { createElement } from '../tree/helpers';\nimport { protectElement, unprotectElement } from '../util/memory';\nimport { parse } from '../util/parser';\nimport { pools } from '../util/pools';\nimport { MiddlewareCache, StateCache } from '../util/cache';\n\n/**\n * If diffHTML is rendering anywhere asynchronously, we need to wait until it\n * completes before this render can be executed. This sets up the next buffer,\n * if necessary, which serves as a Boolean determination later to `bufferSet`.\n *\n * @param {Object} state - The current DOM Node state within diffHTML\n * @param {Object} nextRender - The respective arguments to set buffer\n * @return {Boolean} - Whether or not diffHTML is currently rendering\n */\nconst setBufferState = (state, nextRender) => {\n  // Look up all existing states for any rendering, and set the next render\n  // buffer if blocked.\n  StateCache.forEach(_state => {\n    // If we attach a nextRender, then the buffer has been set.\n    if (_state.isRendering) {\n      state.nextRender = nextRender;\n    }\n  });\n\n  // Let outside code know if we were blocked.\n  return Boolean(state.nextRender);\n};\n\n/**\n * Gets a Virtual Tree Element from the newHTML passed to a diff method.\n *\n * @param {String|Object} newHTML - HTML/DOM Node/Virtual Tree Element\n * @return {Object} - Virtual Tree Element\n */\nconst getTreeFromNewHTML = (newHTML, options, callback) => {\n  // This is HTML Markup, so we need to parse it.\n  if (typeof newHTML === 'string') {\n    const silenceWarnings = options.silenceWarnings;\n    const childNodes = parse(newHTML, null, { silenceWarnings }).childNodes;\n\n    // If we are dealing with innerHTML, use all the Nodes. If we're dealing\n    // with outerHTML, we can only support diffing against a single element,\n    // so pick the first one.\n    return callback(childNodes);\n  }\n  // This is a DOM Node, so we need to convert to a vTree.\n  else if (newHTML.ownerDocument) {\n    const newTree = makeTree(newHTML);\n\n    if (newTree.nodeType === 11) {\n      pools.elementObject.unprotect(newTree);\n      return callback(newTree.childNodes);\n    }\n\n    return callback(newTree);\n  }\n\n  // This is a Virtual Tree Element, or something like it, so we can just pass\n  // it along.\n  return callback(newHTML);\n};\n\n/**\n * Creates a sequential render transaction on a DOM Node. This requires\n * checking for a previous render first. Since diffHTML is globally connected\n * (hopefully only running one copy...), this will prevent transitions from\n * interferring.\n *\n * @param node\n * @param newHTML\n * @param options\n */\nexport default function createTransaction(node, newHTML, options) {\n  if (typeof node !== 'object') {\n    throw new Error('Missing DOM Node object');\n  }\n\n  // Used to associate state with the currently rendering node. This\n  // prevents attaching properties to the instance itself.\n  const state = StateCache.get(node) || {};\n  const isInner = options.inner;\n  const previousMarkup = state.previousMarkup;\n  const previousText = state.previousText;\n  const bufferSet = setBufferState(state, { node, newHTML, options });\n\n  // Associate the current render options with the DOM Node state.\n  state.options = options;\n\n  // Always ensure the most up-to-date state object is stored.\n  StateCache.set(node, state);\n\n  // Short circuit the rest of this render if we ended up having to set a\n  // buffer. This happens when some other code using diffHTML is rendering\n  // asynchronously (using transitions w/ Promise).\n  if (bufferSet) { return; }\n\n  // This looks for changes in the DOM from what we'd expect. This means we\n  // need to rebuild the old Virtual Tree. This allows for keeping our tree in\n  // sync with unexpected DOM changes. It's not very performant, so ideally you\n  // should never change markup that diffHTML affects from outside of diffHTML\n  // if performance is a concern.\n  const sameInnerHTML = isInner ? previousMarkup === node.innerHTML : true;\n  const sameOuterHTML = !isInner ? previousMarkup === node.outerHTML : true;\n  const sameTextContent = previousText === node.textContent;\n\n  // If the contents haven't changed, abort, since there is no point in\n  // continuing. Only support this if the new markup is a string, otherwise\n  // it's possible for our object recycling to match twice.\n  if (typeof newHTML === 'string' && state.newHTML === newHTML) {\n    return;\n  }\n  // Associate the last markup rendered with this node.\n  else if (typeof newHTML === 'string') {\n    state.newHTML = newHTML;\n  }\n\n  // We rebuild the tree whenever the DOM Node changes, including the first\n  // time we patch a DOM Node.\n  const rebuildTree = () => {\n    const oldTree = state.oldTree;\n\n    if (oldTree) {\n      unprotectElement(oldTree);\n    }\n\n    state.oldTree = protectElement(makeTree(node));\n  };\n\n  if (!sameInnerHTML || !sameOuterHTML || !sameTextContent) {\n    rebuildTree();\n  }\n\n  // We're rendering in the UI thread.\n  state.isRendering = true;\n\n  // Store all transaction starting middleware functions being executed here.\n  const startTransactionMiddlewares = [];\n\n  // Start off the middleware execution.\n  MiddlewareCache.forEach(executeMiddleware => {\n    // Pass the start transaction call with the input arguments.\n    const result = executeMiddleware({ node, newHTML, options });\n\n    if (result) {\n      startTransactionMiddlewares.push(result);\n    }\n  });\n\n  // Alias the `oldTree` off of state for parity.\n  const oldTree = state.oldTree;\n\n  // We need to ensure that our target to diff is a Virtual Tree Element. This\n  // function takes in whatever `newHTML` is and normalizes to a tree object.\n  // The callback function runs on every normalized Node to wrap childNodes\n  // in the case of setting innerHTML.\n  const newTree = getTreeFromNewHTML(newHTML, options, newTree => {\n    if (isInner) {\n      pools.elementObject.unprotect(newTree);\n\n      const nodeName = state.oldTree.nodeName;\n      const attributes = state.oldTree.attributes;\n\n      return createElement(nodeName, attributes, newTree);\n    }\n\n    return Array.isArray(newTree) ? newTree[0] : newTree;\n  });\n\n  // Trigger any middleware with the DOM Node, old Virtual Tree Element, and\n  // new Virtual Tree Element. This allows the middleware to mutate and inspect\n  // the trees before they get consumed by diffHTML.\n  const prePatchMiddlewares = [];\n\n  // By exposing the internal tree synchronization and DOM Node patch methods,\n  // a middleware could implement sync/patch on a separate thread.\n  const transactionMethods = {\n    syncTree,\n    patchNode,\n    protectElement,\n    unprotectElement,\n  };\n\n  // Save the current transaction tree state and allow the mdidleware to\n  // override the trees.\n  const transactionState = {\n    oldTree,\n    newTree,\n    transactionMethods,\n  };\n\n  // Run each middleware and pass the transaction state which contains internal\n  // functions otherwise not available by the public API.\n  for (let i = 0; i < startTransactionMiddlewares.length; i++) {\n    // Pass the the existing Virtual Tree Element, and the new Virtual Tree\n    // Element. This is triggered before the synchronization and patching has\n    // occured.\n    const result = startTransactionMiddlewares[i](transactionState);\n\n    if (result) {\n      prePatchMiddlewares.push(result);\n    }\n  }\n\n  // Synchronize the trees, use any middleware replacements, if supplied.\n  const patches = syncTree(transactionState.oldTree, transactionState.newTree);\n\n  // Apply the set of patches to the Node.\n  const promises = patchNode(node, patches);\n\n  // Trigger any middleware after syncing and patching the element. This is\n  // mainly useful to get the Promises for something like devtools and patches\n  // for something like logging.\n  const postPatchMiddlewares = [];\n\n  for (let i = 0; i < prePatchMiddlewares.length; i++) {\n    // The DOM Node patching has finished and now we're sending the patchset\n    // and the promises which can also be pushed into to do some asynchronous\n    // behavior in a middleware.\n    const result = prePatchMiddlewares[i]({\n      patches,\n      promises,\n    });\n\n    if (result) {\n      postPatchMiddlewares.push(result);\n    }\n  }\n\n  // Clean up and finalize this transaction. If there is another transaction,\n  // get a callback to run once this completes to run it.\n  const finalizeTransaction = getFinalizeCallback(node, state);\n\n  // Operate synchronously unless opted into a Promise-chain. Doesn't matter if\n  // they are actually Promises or not, since they will all resolve eventually\n  // with `Promise.all`.\n  if (promises.length) {\n    Promise.all(promises).then(() => {\n      finalizeTransaction(postPatchMiddlewares);\n    }, ex => console.log(ex));\n  }\n  else {\n    // Pass off the remaining middleware to allow users to dive into the\n    // transaction completed lifecycle event.\n    finalizeTransaction(postPatchMiddlewares);\n  }\n}\n"]}