{"version":3,"sources":["../../../lib/node/patch.js"],"names":[],"mappings":"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","file":"patch.js","sourcesContent":["import makeNode from './make';\nimport { makePromises, buildTrigger } from '../util/transitions';\nimport { blockText } from '../util/parser';\nimport { StateCache } from '../util/cache';\nimport { pools } from '../util/pools';\nimport { protectElement, unprotectElement } from '../util/memory';\nimport { decodeEntities } from '../util/entities';\nimport {\n  REMOVE_ELEMENT_CHILDREN,\n  REMOVE_ENTIRE_ELEMENT,\n  REPLACE_ENTIRE_ELEMENT,\n  MODIFY_ELEMENT,\n  MODIFY_ATTRIBUTE,\n  CHANGE_TEXT,\n} from '../tree/sync';\n\nconst isElementNode = node => node.nodeType === 1;\nconst filter = Array.prototype.filter;\n\n/**\n * Looks to see if an element can be replaced. It must have a parentNode to do\n * so. This will trigger an error when the element does not have a parentNode.\n * This typically happens when trying to replace a disconnected DOM Node or the\n * documentElement.\n *\n * @param {String} verb - Verb to replace in the template string\n * @param {Object} oldNode - Old DOM Node to check if able to be replaced\n * @param {Object} patch - Used to clean up vTree references\n */\nconst checkForMissingParent = (verb, oldNode, patch) => {\n  if (!oldNode.parentNode) {\n    // Clean up these elements to keep memory consistent.\n    unprotectElement(patch.old);\n    unprotectElement(patch.new);\n\n    // Throw an error to stop rendering/inform the developer.\n    throw new Error(`\n      Can't ${verb} without parent, is this the document root?\n    `.trim());\n  }\n};\n\n// Trigger the attached transition state for this element and all childNodes.\nconst attach = ({ vTree, fragment, parentNode, triggerTransition, state }) => {\n  // This element has been attached, so it should definitely be marked as\n  // protected.\n  protectElement(vTree);\n\n  // Create a DOM Node for this Virtual Tree element.\n  const node = makeNode(vTree);\n\n  // If the element added was a DOM text node or SVG text element, trigger\n  // the textChanged transition.\n  if (vTree.nodeName === '#text') {\n    const promises = makePromises(\n      'textChanged', [node], null, vTree.nodeValue\n    );\n\n    node.nodeValue = decodeEntities(vTree.nodeValue);\n\n    if (parentNode) {\n      const nodeName = parentNode.nodeName.toLowerCase();\n\n      if (blockText.has(nodeName)) {\n        parentNode.nodeValue = decodeEntities(vTree.nodeValue);\n      }\n    }\n\n    triggerTransition('textChanged', promises);\n  }\n\n  vTree.attributes.forEach(attr => {\n    triggerTransition('attributeChanged', makePromises(\n      'attributeChanged', [node], attr.name, null, attr.value\n    ));\n  });\n\n  // Call all `childNodes` attached callbacks as well.\n  vTree.childNodes.forEach(vTree => attach({\n    vTree, parentNode: node, triggerTransition, state\n  }));\n\n  // If a Document Fragment was specified, append the DOM Node into it.\n  if (fragment) {\n    fragment.appendChild(node);\n  }\n\n  return node;\n};\n\n/**\n * Processes a set of patches onto a tracked DOM Node.\n *\n * @param {Object} node - DOM Node to process patchs on\n * @param {Array} patches - Contains patch objects\n */\nexport default function patchNode(node, patches) {\n  const state = StateCache.get(node);\n  const promises = [];\n  const triggerTransition = buildTrigger(promises);\n\n  // Loop through all the patches and apply them.\n  for (let i = 0; i < patches.length; i++) {\n    const patch = patches[i];\n    const el = makeNode(patch.element);\n    const oldEl = makeNode(patch.old);\n    const newEl = makeNode(patch.new);\n\n    // Empty the Node's contents. This is an optimization, since `innerHTML`\n    // will be faster than iterating over every element and manually removing.\n    if (patch.__do__ === REMOVE_ELEMENT_CHILDREN) {\n      const childNodes = filter.call(el.childNodes, isElementNode);\n      const detachPromises = makePromises('detached', childNodes);\n\n      triggerTransition('detached', detachPromises, promises => {\n        const callback = () => {\n          unprotectElement(patch.toRemove);\n          el.innerHTML = '';\n        };\n\n        if (promises && promises.length) {\n          Promise.all(promises).then(callback);\n        }\n        else {\n          callback();\n        }\n      });\n    }\n\n    // Remove the entire Node. Only does something if the Node has a parent\n    // element.\n    else if (patch.__do__ === REMOVE_ENTIRE_ELEMENT) {\n      const childNodes = [el].filter(isElementNode);\n      const detachPromises = makePromises('detached', childNodes);\n\n      if (el.parentNode) {\n        triggerTransition('detached', detachPromises, promises => {\n          const callback = () => {\n            el.parentNode.removeChild(el);\n            unprotectElement(patch.toRemove);\n          };\n\n          if (promises && promises.length) {\n            Promise.all(promises).then(callback);\n          }\n          else {\n            callback();\n          }\n        });\n      }\n      else {\n        unprotectElement(patch.toRemove);\n      }\n    }\n\n    // Replace the entire Node.\n    else if (patch.__do__ === REPLACE_ENTIRE_ELEMENT) {\n      const allPromises = [];\n\n      const attachedPromises = makePromises('attached', [\n        newEl\n      ].filter(isElementNode));\n\n      const detachedPromises = makePromises('detached', [\n        oldEl\n      ].filter(isElementNode));\n\n      const replacedPromises = makePromises(\n        'replaced', [oldEl], newEl\n      );\n\n      // Add all the transition state promises into the main array, we'll use\n      // them all to decide when to alter the DOM.\n      triggerTransition('detached', detachedPromises, promises => {\n        allPromises.push.apply(allPromises, promises);\n      });\n\n      triggerTransition('attached', attachedPromises, promises => {\n        allPromises.push.apply(allPromises, promises);\n        attach({ vTree: patch.new, triggerTransition, state });\n      });\n\n      triggerTransition('replaced', replacedPromises, promises => {\n        allPromises.push.apply(allPromises, promises);\n      });\n\n      unprotectElement(patch.old);\n\n      // Reset the tree cache. TODO Look into this...\n      StateCache.set(newEl, {\n        oldTree: patch.new,\n        element: newEl\n      });\n\n      // Once all the promises have completed, invoke the action, if no\n      // promises were added, this will be a synchronous operation.\n      if (allPromises.length) {\n        Promise.all(allPromises).then(function replaceEntireElement() {\n          checkForMissingParent(oldEl, patch);\n          oldEl.parentNode.replaceChild(newEl, oldEl);\n        }, ex => console.log(ex));\n      }\n      else {\n        if (!oldEl.parentNode) {\n          unprotectElement(patch.new);\n\n          if (StateCache.has(newEl)) {\n            StateCache.delete(newEl);\n          }\n\n          throw new Error(replaceFailMsg);\n        }\n\n        oldEl.parentNode.replaceChild(newEl, oldEl);\n      }\n    }\n\n    // Node manip.\n    else if (patch.__do__ === MODIFY_ELEMENT) {\n      // Add.\n      if (el && patch.fragment && !oldEl) {\n        const fragment = document.createDocumentFragment();\n\n        // Loop over every element to be added and process the Virtual Tree\n        // element into the DOM Node and append into the DOM fragment.\n        const toAttach = patch.fragment.map(vTree => attach({\n          vTree, fragment, triggerTransition, state\n        })).filter(isElementNode);\n\n        // Turn elements into childNodes of the patch element.\n        el.appendChild(fragment);\n\n        // Trigger transitions.\n        const makeAttached = makePromises('attached', toAttach);\n        triggerTransition('attached', makeAttached);\n      }\n\n      // Remove.\n      else if (oldEl && !newEl) {\n        // Ensure we can remove the old DOM Node.\n        checkForMissingParent('remove', oldEl, patch);\n\n        const makeDetached = makePromises('detached', [oldEl]);\n\n        triggerTransition('detached', makeDetached, (promises) => {\n          const callback = () => {\n            if (oldEl.parentNode) {\n              oldEl.parentNode.removeChild(oldEl);\n            }\n\n            // And then empty out the entire contents.\n            oldEl.innerHTML = '';\n\n            unprotectElement(patch.old);\n          };\n\n          if (promises && promises.length) {\n            Promise.all(promises).then(callback);\n          }\n          else {\n            callback();\n          }\n        });\n      }\n\n      // Replace.\n      else if (oldEl && newEl) {\n        // Ensure we can replace the old DOM Node.\n        checkForMissingParent('replace', oldEl, patch);\n\n        // Append the element first, before doing the replacement.\n        if (oldEl.nextSibling) {\n          oldEl.parentNode.insertBefore(newEl, oldEl.nextSibling);\n        }\n        else {\n          oldEl.parentNode.appendChild(newEl);\n        }\n\n        // Removed state for transitions API.\n        const allPromises = [];\n\n        const attachPromises = makePromises('attached', [\n          newEl\n        ].filter(isElementNode));\n\n        const detachPromises = makePromises('detached', [\n          oldEl\n        ].filter(isElementNode));\n\n        const replacePromises = makePromises(\n          'replaced', [oldEl], newEl\n        );\n\n        triggerTransition('replaced', replacePromises, promises => {\n          if (promises && promises.length) {\n            allPromises.push.apply(allPromises, promises);\n          }\n        });\n\n        triggerTransition('detached', detachPromises, promises => {\n          if (promises && promises.length) {\n            allPromises.push.apply(allPromises, promises);\n          }\n        });\n\n        triggerTransition('attached', attachPromises, promises => {\n          if (promises && promises.filter(Boolean).length) {\n            allPromises.push.apply(allPromises, promises);\n          }\n\n          attach({ vTree: patch.new, triggerTransition, state });\n        });\n\n        // Once all the promises have completed, invoke the action, if no\n        // promises were added, this will be a synchronous operation.\n        if (allPromises.length) {\n          Promise.all(allPromises).then(function replaceElement() {\n            if (oldEl.parentNode) {\n              oldEl.parentNode.replaceChild(newEl, oldEl);\n            }\n\n            unprotectElement(patch.old);\n\n            protectElement(patch.new);\n          }, ex => console.log(ex));\n        }\n        else {\n          checkForMissingParent('replace', oldEl, patch);\n\n          oldEl.parentNode.replaceChild(newEl, oldEl);\n          unprotectElement(patch.old);\n          protectElement(patch.new);\n        }\n      }\n    }\n\n    // Attribute manipulation.\n    else if (patch.__do__ === MODIFY_ATTRIBUTE) {\n      const attributes = patch.attributes;\n\n      attributes.forEach(({ oldAttr, newAttr }) => {\n        const name = newAttr ? newAttr.name : oldAttr.name;\n        const value = (oldAttr ? oldAttr.value : undefined) || null;\n\n        const attrChangePromises = makePromises(\n          'attributeChanged', [el], name, value, newAttr ? newAttr.value : null\n        );\n\n        triggerTransition('attributeChanged', attrChangePromises, promises => {\n          const callback = () => {\n            // Always remove the old attribute, we never re-use it.\n            if (oldAttr) {\n              pools.attributeObject.unprotect(oldAttr);\n\n              // Remove the Virtual Tree Attribute from the element and memory.\n              if (!newAttr) {\n                el.removeAttribute(oldAttr.name);\n\n                if (oldAttr.name in el) {\n                  el[oldAttr.name] = undefined;\n                }\n              }\n            }\n\n            // Add/Change the attribute or property.\n            if (newAttr) {\n              const isObject = typeof newAttr.value === 'object';\n              const isFunction = typeof newAttr.value === 'function';\n\n              // Protect the Virtual Attribute object.\n              pools.attributeObject.protect(newAttr);\n\n              // If not a dynamic type, set as an attribute, since it's a valid\n              // attribute value.\n              if (!isObject && !isFunction) {\n                if (newAttr.name) {\n                  el.setAttribute(newAttr.name, decodeEntities(newAttr.value));\n                }\n              }\n              else if (typeof newAttr.value !== 'string') {\n                // Necessary to track the attribute/prop existence.\n                el.setAttribute(newAttr.name, '');\n\n                // Since this is a dynamic value it gets set as a property.\n                el[newAttr.name] = newAttr.value;\n              }\n\n              // Support live updating of the value attribute.\n              if (newAttr.name === 'value' || newAttr.name === 'checked') {\n                el[newAttr.name] = newAttr.value;\n              }\n            }\n          };\n\n          if (promises && promises.length) {\n            Promise.all(promises).then(\n              callback, function unhandledException() {}\n            );\n          }\n          else {\n            callback();\n          }\n        });\n      });\n    }\n\n    // Text node manipulation.\n    else if (patch.__do__ === CHANGE_TEXT) {\n      const textChangePromises = makePromises('textChanged',\n        [el], el.nodeValue, patch.value);\n\n      triggerTransition('textChanged', textChangePromises, promises => {\n        const callback = () => {\n          patch.element.nodeValue = decodeEntities(patch.value);\n          el.nodeValue = patch.element.nodeValue;\n\n          if (el.parentNode) {\n            const nodeName = el.parentNode.nodeName.toLowerCase();\n\n            if (blockText.has(nodeName)) {\n              el.parentNode.nodeValue = decodeEntities(patch.element.nodeValue);\n            }\n          }\n        };\n\n        if (promises && promises.length) {\n          Promise.all(promises).then(callback);\n        }\n        else {\n          callback();\n        }\n      });\n    }\n  }\n\n  // Return the Promises that were allocated so that rendering can be blocked\n  // until they resolve.\n  return promises.filter(Boolean);\n}\n"]}