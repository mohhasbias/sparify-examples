{"version":3,"sources":["../../../lib/node/finalize.js"],"names":[],"mappings":";;;;;kBA2BwB,mB;;AA3BxB;;;;AACA;;AACA;;;;AAEA;;;;;;AAMA,IAAM,aAAa,SAAb,UAAa,CAAC,KAAD,EAAW;AAC5B,MAAM,aAAa,MAAM,UAAzB;AACA,QAAM,UAAN,GAAmB,SAAnB;;AAEA,6BAAkB,WAAW,IAA7B,EAAmC,WAAW,OAA9C,EAAuD,WAAW,OAAlE;AACD,CALD;;AAOA;;;;;;;;;;AAUe,SAAS,mBAAT,CAA6B,IAA7B,EAAmC,KAAnC,EAA0C;AACvD;;;;;;AAMA,SAAO,SAAS,mBAAT,GAAuD;AAAA,QAA1B,mBAA0B,yDAAJ,EAAI;;AAC5D,QAAM,UAAU,MAAM,OAAN,CAAc,KAA9B;;AAEA,UAAM,cAAN,GAAuB,UAAU,KAAK,SAAf,GAA2B,KAAK,SAAvD;AACA,UAAM,YAAN,GAAqB,KAAK,WAA1B;;AAEA,UAAM,WAAN,GAAoB,KAApB;;AAEA;AACA;AACA;AACA,QAAI,MAAM,UAAV,EAAsB;AACpB,iBAAW,KAAX;AACD;AACD;AACA;AAJA,SAKK;AAAA;AAAA;AAAA;;AAAA;AACH,+BAAkB,kBAAW,OAAX,EAAlB,8HAAwC;AAAA,gBAA/B,MAA+B;;AACtC,gBAAI,OAAM,UAAV,EAAsB;AACpB,yBAAW,MAAX;AACA;AACD;AACF;AANE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOJ;;AAED;AACA;;AAEA;AACA,SAAK,IAAI,IAAE,CAAX,EAAc,IAAI,oBAAoB,MAAtC,EAA8C,GAA9C,EAAmD;AACjD,0BAAoB,CAApB;AACD;AACF,GAhCD;AAiCD","file":"finalize.js","sourcesContent":["import createTransaction from '../node/transaction';\nimport { StateCache } from '../util/cache';\nimport { cleanMemory } from '../util/memory';\n\n/**\n * Pulls the next render object (containing the respective arguments to\n * patchNode) and invokes the next transaction.\n *\n * @param state\n */\nconst renderNext = (state) => {\n  const nextRender = state.nextRender;\n  state.nextRender = undefined;\n\n  createTransaction(nextRender.node, nextRender.newHTML, nextRender.options);\n};\n\n/**\n * Returns a callback that finalizes the transaction, setting the isRendering\n * flag to false. This allows us to pick off and invoke the next available\n * transaction to render. This code recyles the unprotected allocated pool\n * objects and triggers a `renderComplete` event.\n *\n * @param {Object} node - A DOM Node that has just had patches applied\n * @param {Object} state - The current state object associated with the Node\n * @return {Function} - Closure that when called completes the transaction\n */\nexport default function getFinalizeCallback(node, state) {\n  /**\n   * When the render completes, clean up memory, and schedule the next render\n   * if necessary.\n   *\n   * @param {Array} remainingMiddleware - Array of middleware to invoke\n   */\n  return function finalizeTransaction(remainingMiddleware = []) {\n    const isInner = state.options.inner;\n\n    state.previousMarkup = isInner ? node.innerHTML : node.outerHTML;\n    state.previousText = node.textContent;\n\n    state.isRendering = false;\n\n    // This is designed to handle use cases where renders are being hammered\n    // or when transitions are used with Promises. If this element has a next\n    // render state, trigger it first as priority.\n    if (state.nextRender) {\n      renderNext(state);\n    }\n    // Otherwise dig into the other states and pick off the first one\n    // available.\n    else {\n      for (let state of StateCache.entries()) {\n        if (state.nextRender) {\n          renderNext(state);\n          break;\n        }\n      }\n    }\n\n    // Clean out all the existing allocations.\n    cleanMemory();\n\n    // Call the remaining middleware signaling the render is complete.\n    for (let i=0; i < remainingMiddleware.length; i++) {\n      remainingMiddleware[i]();\n    }\n  };\n}\n"]}