'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getFinalizeCallback;

var _transaction = require('../node/transaction');

var _transaction2 = _interopRequireDefault(_transaction);

var _cache = require('../util/cache');

var _memory = require('../util/memory');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Pulls the next render object (containing the respective arguments to
 * patchNode) and invokes the next transaction.
 *
 * @param state
 */
var renderNext = function renderNext(state) {
  var nextRender = state.nextRender;
  state.nextRender = undefined;

  (0, _transaction2.default)(nextRender.node, nextRender.newHTML, nextRender.options);
};

/**
 * Returns a callback that finalizes the transaction, setting the isRendering
 * flag to false. This allows us to pick off and invoke the next available
 * transaction to render. This code recyles the unprotected allocated pool
 * objects and triggers a `renderComplete` event.
 *
 * @param {Object} node - A DOM Node that has just had patches applied
 * @param {Object} state - The current state object associated with the Node
 * @return {Function} - Closure that when called completes the transaction
 */
function getFinalizeCallback(node, state) {
  /**
   * When the render completes, clean up memory, and schedule the next render
   * if necessary.
   *
   * @param {Array} remainingMiddleware - Array of middleware to invoke
   */
  return function finalizeTransaction() {
    var remainingMiddleware = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

    var isInner = state.options.inner;

    state.previousMarkup = isInner ? node.innerHTML : node.outerHTML;
    state.previousText = node.textContent;

    state.isRendering = false;

    // This is designed to handle use cases where renders are being hammered
    // or when transitions are used with Promises. If this element has a next
    // render state, trigger it first as priority.
    if (state.nextRender) {
      renderNext(state);
    }
    // Otherwise dig into the other states and pick off the first one
    // available.
    else {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = _cache.StateCache.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _state = _step.value;

            if (_state.nextRender) {
              renderNext(_state);
              break;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

    // Clean out all the existing allocations.
    (0, _memory.cleanMemory)();

    // Call the remaining middleware signaling the render is complete.
    for (var i = 0; i < remainingMiddleware.length; i++) {
      remainingMiddleware[i]();
    }
  };
}
//# sourceMappingURL=finalize.js.map