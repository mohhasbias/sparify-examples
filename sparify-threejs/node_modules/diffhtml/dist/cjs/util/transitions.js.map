{"version":3,"sources":["../../../lib/util/transitions.js"],"names":[],"mappings":"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","file":"transitions.js","sourcesContent":["const forEach = Array.prototype.forEach;\n\n/**\n * Contains arrays to store transition callbacks.\n *\n * attached\n * --------\n *\n * For when elements come into the DOM. The callback triggers immediately after\n * the element enters the DOM. It is called with the element as the only\n * argument.\n *\n * detached\n * --------\n *\n * For when elements are removed from the DOM. The callback triggers just\n * before the element leaves the DOM. It is called with the element as the only\n * argument.\n *\n * replaced\n * --------\n *\n * For when elements are replaced in the DOM. The callback triggers after the\n * new element enters the DOM, and before the old element leaves. It is called\n * with old and new elements as arguments, in that order.\n *\n * attributeChanged\n * ----------------\n *\n * Triggered when an element's attribute has changed. The callback triggers\n * after the attribute has changed in the DOM. It is called with the element,\n * the attribute name, old value, and current value.\n *\n * textChanged\n * -----------\n *\n * Triggered when an element's `textContent` chnages. The callback triggers\n * after the textContent has changed in the DOM. It is called with the element,\n * the old value, and current value.\n */\nexport const states = {\n  attached: [],\n  detached: [],\n  replaced: [],\n  attributeChanged: [],\n  textChanged: [],\n};\n\n// Define the custom signatures necessary for the loop to fill in the \"magic\"\n// methods that process the transitions consistently.\nconst fnSignatures = {\n  attached: el => cb => cb(el),\n  detached: el => cb => cb(el),\n  replaced: (oldEl, newEl) => cb => cb(oldEl, newEl),\n  textChanged: (el, oldVal, newVal) => cb => cb(el, oldVal, newVal),\n  attributeChanged: (el, name, oldVal, newVal) => cb => cb(\n    el, name, oldVal, newVal\n  ),\n};\n\nconst make = {};\n\n// Dynamically fill in the custom methods instead of manually constructing\n// them.\nObject.keys(states).forEach(stateName => {\n  const mapFn = fnSignatures[stateName];\n\n  /**\n   * Make's the transition promises.\n   *\n   * @param elements\n   * @param args\n   * @param promises\n   */\n  make[stateName] = function makeTransitionPromises(elements, args, promises) {\n    // Sometimes an array-like is passed so using forEach in this manner yields\n    // more consistent results.\n    forEach.call(elements, element => {\n      // Never pass text nodes to a state callback unless it is textChanged.\n      if (stateName !== 'textChanged' && element.nodeType !== 1) {\n        return;\n      }\n\n      // Call the map function with each element.\n      const newPromises = states[stateName].map(\n        mapFn.apply(null, [element].concat(args))\n      );\n\n      // Merge these Promises into the main cache.\n      promises.push.apply(promises, newPromises);\n\n      // Recursively call into the children if attached or detached.\n      if (stateName === 'attached' || stateName === 'detached') {\n        make[stateName](element.childNodes, args, promises);\n      }\n    });\n\n    return promises.filter(promise => Boolean(promise && promise.then));\n  };\n});\n\n/**\n * Builds a reusable trigger mechanism for the element transitions.\n *\n * @param allPromises\n */\nexport function buildTrigger(allPromises) {\n  const addPromises = allPromises.push.apply.bind(\n    allPromises.push, allPromises\n  );\n\n  // This becomes `triggerTransition` in process.js.\n  return (stateName, makePromisesCallback, callback) => {\n    if (states[stateName] && states[stateName].length) {\n      // Calls into each custom hook to bind Promises into the local array,\n      // these will then get merged into the main `allPromises` array.\n      const promises = makePromisesCallback([]);\n\n      // Add these promises into the global cache.\n      addPromises(promises);\n\n      if (callback) {\n        callback(promises.length ? promises : undefined);\n      }\n    }\n    else if (callback) {\n      callback();\n    }\n  };\n}\n\n/**\n * Make a reusable function for easy transition calling.\n *\n * @param stateName\n */\nexport function makePromises(stateName, ...args) {\n  // Ensure elements is always an array.\n  const elements = [].concat(args[0]);\n\n  // Accepts the local Array of promises to use.\n  return promises => make[stateName](elements, args.slice(1), promises);\n}\n"]}