{"version":3,"sources":["../../../lib/util/memory.js"],"names":[],"mappings":";;;;;QASgB,c,GAAA,c;QAsBA,gB,GAAA,gB;QAqBA,W,GAAA,W;;AApDhB;;AACA;;AAEA;;;;;;AAMO,SAAS,cAAT,CAAwB,OAAxB,EAAiC;AACtC,MAAI,MAAM,OAAN,CAAc,OAAd,CAAJ,EAA4B;AAC1B,WAAO,QAAQ,OAAR,CAAgB,cAAhB,CAAP;AACD;;AAED,MAAM,gBAAgB,aAAM,aAA5B;AACA,MAAM,kBAAkB,aAAM,eAA9B;;AAEA,gBAAc,OAAd,CAAsB,OAAtB;;AAEA,UAAQ,UAAR,CAAmB,OAAnB,CAA2B,gBAAgB,OAA3C,EAAoD,eAApD;AACA,UAAQ,UAAR,CAAmB,OAAnB,CAA2B,cAA3B;;AAEA,SAAO,OAAP;AACD;;AAED;;;;;;AAMO,SAAS,gBAAT,CAA0B,OAA1B,EAAmC;AACxC,MAAI,MAAM,OAAN,CAAc,OAAd,CAAJ,EAA4B;AAC1B,WAAO,QAAQ,OAAR,CAAgB,gBAAhB,CAAP;AACD;;AAED,MAAM,gBAAgB,aAAM,aAA5B;AACA,MAAM,kBAAkB,aAAM,eAA9B;;AAEA,gBAAc,SAAd,CAAwB,OAAxB;;AAEA,UAAQ,UAAR,CAAmB,OAAnB,CAA2B,gBAAgB,SAA3C,EAAsD,eAAtD;AACA,UAAQ,UAAR,CAAmB,OAAnB,CAA2B,gBAA3B;;AAEA,mBAAU,MAAV,CAAiB,OAAjB;;AAEA,SAAO,OAAP;AACD;;AAED;;;AAGO,SAAS,WAAT,GAAuB;AAC5B,MAAM,eAAe,aAAM,aAAN,CAAoB,KAAzC;AACA,MAAM,iBAAiB,aAAM,eAAN,CAAsB,KAA7C;;AAEA;AACA,eAAa,SAAb,CAAuB,OAAvB,CAA+B,aAAK;AAClC,QAAI,aAAa,IAAb,CAAkB,MAAlB,eAAJ,EAAsC;AACpC,mBAAa,IAAb,CAAkB,IAAlB,CAAuB,CAAvB;AACD;AACF,GAJD;;AAMA,eAAa,SAAb,CAAuB,KAAvB;;AAEA;AACA,mBAAU,OAAV,CAAkB,UAAC,IAAD,EAAO,UAAP,EAAsB;AACtC,QAAI,CAAC,aAAa,SAAb,CAAuB,GAAvB,CAA2B,UAA3B,CAAL,EAA6C;AAC3C,uBAAU,MAAV,CAAiB,UAAjB;AACD;AACF,GAJD;;AAMA;AACA,iBAAe,SAAf,CAAyB,OAAzB,CAAiC,aAAK;AACpC,QAAI,eAAe,IAAf,CAAoB,MAApB,eAAJ,EAAwC;AACtC,qBAAe,IAAf,CAAoB,IAApB,CAAyB,CAAzB;AACD;AACF,GAJD;;AAMA,iBAAe,SAAf,CAAyB,KAAzB;AACD","file":"memory.js","sourcesContent":["import { count, pools } from '../util/pools';\nimport { NodeCache } from './cache';\n\n/**\n * Ensures that an element is not recycled during a render cycle.\n *\n * @param element\n * @return element\n */\nexport function protectElement(element) {\n  if (Array.isArray(element)) {\n    return element.forEach(protectElement);\n  }\n\n  const elementObject = pools.elementObject;\n  const attributeObject = pools.attributeObject;\n\n  elementObject.protect(element);\n\n  element.attributes.forEach(attributeObject.protect, attributeObject);\n  element.childNodes.forEach(protectElement);\n\n  return element;\n}\n\n/**\n * Allows an element to be recycled during a render cycle.\n *\n * @param element\n * @return\n */\nexport function unprotectElement(element) {\n  if (Array.isArray(element)) {\n    return element.forEach(unprotectElement);\n  }\n\n  const elementObject = pools.elementObject;\n  const attributeObject = pools.attributeObject;\n\n  elementObject.unprotect(element);\n\n  element.attributes.forEach(attributeObject.unprotect, attributeObject);\n  element.childNodes.forEach(unprotectElement);\n\n  NodeCache.delete(element);\n\n  return element;\n}\n\n/**\n * Recycles all unprotected allocations.\n */\nexport function cleanMemory() {\n  const elementCache = pools.elementObject.cache;\n  const attributeCache = pools.attributeObject.cache;\n\n  // Empty all element allocations.\n  elementCache.allocated.forEach(v => {\n    if (elementCache.free.length < count) {\n      elementCache.free.push(v);\n    }\n  });\n\n  elementCache.allocated.clear();\n\n  // Clean out unused elements.\n  NodeCache.forEach((node, descriptor) => {\n    if (!elementCache.protected.has(descriptor)) {\n      NodeCache.delete(descriptor);\n    }\n  });\n\n  // Empty all attribute allocations.\n  attributeCache.allocated.forEach(v => {\n    if (attributeCache.free.length < count) {\n      attributeCache.free.push(v);\n    }\n  });\n\n  attributeCache.allocated.clear();\n}\n"]}