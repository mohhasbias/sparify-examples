{"version":3,"sources":["../../../lib/util/tagged-template.js"],"names":[],"mappings":";;;;;;;;QA2BgB,I,GAAA,I;;AA3BhB;;AACA;;;;;;AAEA,IAAM,WAAW,SAAjB;AACA,IAAM,QAAQ,cAAd;;AAEA;;;;;;;AAOA,IAAM,YAAY,SAAZ,SAAY,CAAC,MAAD,EAAY;AAC5B,MAAM,QAAQ,OAAO,KAAP,EAAd;AACA,SAAO,OAAO,KAAP,KAAiB,QAAjB,GAA4B,sBAAO,KAAP,CAA5B,GAA4C,KAAnD;AACD,CAHD;;AAKA;;;;;;;;;AASO,SAAS,IAAT,CAAc,OAAd,EAAkC;AAAA,oCAAR,MAAQ;AAAR,UAAQ;AAAA;;AACvC;AACA,MAAI,OAAO,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,cAAU,CAAC,OAAD,CAAV;AACD;;AAED;AACA,MAAI,CAAC,QAAQ,CAAR,EAAW,MAAZ,IAAsB,CAAC,OAAO,MAAlC,EAA0C;AACxC,WAAO,IAAP;AACD;;AAED;AACA,MAAI,QAAQ,MAAR,KAAmB,CAAnB,IAAwB,CAAC,OAAO,MAApC,EAA4C;AAC1C,QAAM,cAAa,mBAAM,QAAQ,CAAR,CAAN,EAAkB,UAArC;AACA,WAAO,YAAW,MAAX,GAAoB,CAApB,GAAwB,WAAxB,GAAqC,YAAW,CAAX,CAA5C;AACD;;AAED;AACA,MAAM,SAAS,EAAf;;AAEA;AACA;AACA,MAAM,eAAe;AACnB,WAAO,EADY;AAEnB,cAAU;AAFS,GAArB;;AAKA;AACA;AACA;AACA;AACA;AACA,UAAQ,OAAR,CAAgB,kBAAU;AACxB;AACA,WAAO,IAAP,CAAY,MAAZ;;AAEA,QAAI,OAAO,MAAX,EAAmB;AACjB,UAAM,QAAQ,UAAU,MAAV,CAAd;AACA,UAAM,cAAc,OAAO,KAAP,CAAa,GAAb,EAAkB,GAAlB,EAApB;AACA,UAAM,gBAAgB,YAAY,IAAZ,GAAmB,KAAnB,CAAyB,CAAC,CAA1B,CAAtB;AACA,UAAM,SAAS,QAAQ,cAAc,KAAd,CAAoB,QAApB,CAAR,CAAf;;AAEA,UAAI,MAAJ,EAAY;AACV,qBAAa,KAAb,CAAmB,IAAnB,CAAwB,KAAxB;AACA,eAAO,IAAP,CAAY,KAAZ;AACD,OAHD,MAIK,IAAI,MAAM,OAAN,CAAc,KAAd,KAAwB,QAAO,KAAP,yCAAO,KAAP,OAAiB,QAA7C,EAAuD;AAC1D,qBAAa,QAAb,CAAsB,IAAtB,CAA2B,KAA3B;AACA,eAAO,IAAP,CAAY,KAAZ;AACD,OAHI,MAIA;AACH,eAAO,IAAP,CAAY,KAAZ;AACD;AACF;AACF,GAtBD;;AAwBA;AACA,MAAM,aAAa,mBAAM,OAAO,IAAP,CAAY,EAAZ,CAAN,EAAuB,YAAvB,EAAqC,UAAxD;;AAEA;AACA;AACA,SAAO,WAAW,MAAX,GAAoB,CAApB,GAAwB,UAAxB,GAAqC,WAAW,CAAX,CAA5C;AACD","file":"tagged-template.js","sourcesContent":["import { parse } from './parser';\nimport escape from './escape';\n\nconst isPropEx = /(=|'|\")/;\nconst TOKEN = '__DIFFHTML__';\n\n/**\n * Get the next value from the list. If the next value is a string, make sure\n * it is escaped.\n *\n * @param {Array} values - Values extracted from tagged template literal\n * @return {String|*} - Escaped string, otherwise any value passed\n */\nconst nextValue = (values) => {\n  const value = values.shift();\n  return typeof value === 'string' ? escape(value) : value;\n};\n\n/**\n * Parses tagged template contents into a Virtual Tree. These tagged templates\n * separate static strings from values, so we need to do some special token\n * work\n *\n * @param {Array} strings - A list of static strings, split by value\n * @param {Array} ...values - A list of interpolated values\n * @return {Object|Array} - A Virtual Tree Element or array of elements\n */\nexport function html(strings, ...values) {\n  // Automatically coerce a string literal to array.\n  if (typeof strings === 'string') {\n    strings = [strings];\n  }\n\n  // Do not attempt to parse empty strings.\n  if (!strings[0].length && !values.length) {\n    return null;\n  }\n\n  // Parse only the text, no dynamic bits.\n  if (strings.length === 1 && !values.length) {\n    const childNodes = parse(strings[0]).childNodes;\n    return childNodes.length > 1 ? childNodes : childNodes[0];\n  }\n\n  // Used to store markup and tokens.\n  const retVal = [];\n\n  // We filter the supplemental values by where they are used. Values are\n  // either props or children.\n  const supplemental = {\n    props: [],\n    children: [],\n  };\n\n  // Loop over the static strings, each break correlates to an interpolated\n  // value. Since these values can be dynamic, we cannot pass them to the\n  // diffHTML HTML parser inline. They are passed as an additional argument\n  // called supplemental. The following loop instruments the markup with tokens\n  // that the parser then uses to assemble the correct tree.\n  strings.forEach(string => {\n    // Always add the string, we need it to parse the markup later.\n    retVal.push(string);\n\n    if (values.length) {\n      const value = nextValue(values);\n      const lastSegment = string.split(' ').pop();\n      const lastCharacter = lastSegment.trim().slice(-1);\n      const isProp = Boolean(lastCharacter.match(isPropEx));\n\n      if (isProp) {\n        supplemental.props.push(value);\n        retVal.push(TOKEN);\n      }\n      else if (Array.isArray(value) || typeof value === 'object') {\n        supplemental.children.push(value);\n        retVal.push(TOKEN);\n      }\n      else {\n        retVal.push(value);\n      }\n    }\n  });\n\n  // Parse the instrumented markup to get the Virtual Tree.\n  const childNodes = parse(retVal.join(''), supplemental).childNodes;\n\n  // This makes it easier to work with a single element as a root, instead of\n  // always return an array.\n  return childNodes.length > 1 ? childNodes : childNodes[0];\n}\n"]}