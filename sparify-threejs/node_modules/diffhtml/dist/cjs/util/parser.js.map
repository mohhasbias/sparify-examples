{"version":3,"sources":["../../../lib/util/parser.js"],"names":[],"mappings":"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","file":"parser.js","sourcesContent":["// Code based off of:\n// https://github.com/ashi009/node-fast-html-parser\n\nimport { pools } from './pools';\nimport makeTree from '../tree/make';\nimport { createElement, createAttribute } from '../tree/helpers';\nimport escape from './escape';\n\nconst TOKEN = '__DIFFHTML__';\n\nconst doctypeEx = /<!.*>/ig;\nconst attrEx = /\\b([_a-z][_a-z0-9\\-]*)\\s*(=\\s*(\"([^\"]+)\"|'([^']+)'|(\\S+)))?/ig;\nconst tagEx =\n  /<!--[^]*?(?=-->)-->|<(\\/?)([a-z\\-][a-z0-9\\-]*)\\s*([^>]*?)(\\/?)>/ig;\nconst spaceEx = /[^ ]/;\n\n// We use this Set in the node/patch module so marking it exported.\nexport const blockText = new Set([\n  'script',\n  'noscript',\n  'style',\n  'code',\n  'template',\n]);\n\nconst selfClosing = new Set([\n  'meta',\n  'img',\n  'link',\n  'input',\n  'area',\n  'br',\n  'hr',\n]);\n\nconst kElementsClosedByOpening = {\n  li: { li: true },\n  p: { p: true, div: true },\n  td: { td: true, th: true },\n  th: { td: true, th: true },\n};\n\nconst kElementsClosedByClosing = {\n  li: { ul: true, ol: true },\n  a: { div: true },\n  b: { div: true },\n  i: { div: true },\n  p: { div: true },\n  td: { tr: true, table: true },\n  th: { tr: true, table: true },\n};\n\n/**\n * Interpolate dynamic supplemental values from the tagged template into the\n * tree.\n *\n * @param currentParent\n * @param string\n * @param supplemental\n */\nconst interpolateDynamicBits = (currentParent, string, supplemental) => {\n  if (string && string.indexOf(TOKEN) > -1) {\n    const toAdd = [];\n\n    // Break up the incoming string into dynamic parts that are then pushed\n    // into a new set of child nodes.\n    string.split(TOKEN).forEach((value, index) => {\n      if (index === 0) {\n        // We trim here to allow for newlines before and after markup starts.\n        if (value && value.trim()) {\n          toAdd.push(TextNode(value));\n        }\n\n        // The first item does not mean there was dynamic content.\n        return;\n      }\n\n      // If we are in the second iteration, this\n      const dynamicBit = supplemental.children.shift();\n\n      if (typeof dynamicBit === 'string') {\n        toAdd.push(TextNode(dynamicBit));\n      }\n      else if (Array.isArray(dynamicBit)) {\n        toAdd.push.apply(toAdd, dynamicBit);\n      }\n      else if (dynamicBit.ownerDocument) {\n        toAdd.push(makeTree(dynamicBit));\n      }\n      else {\n        toAdd.push(dynamicBit);\n      }\n\n      // This is a useful Text Node.\n      if (value && value.trim()) {\n        toAdd.push(TextNode(value));\n      }\n    });\n\n    currentParent.childNodes.push.apply(currentParent.childNodes, toAdd);\n  }\n  else if (string && string.length && !doctypeEx.exec(string)) {\n    currentParent.childNodes.push(TextNode(string));\n  }\n};\n\n/**\n * TextNode to contain a text element in DOM tree.\n *\n * @param {String} nodeValue - A value to set in the text,, set unescaped\n * @return {Object} - A Virtual Tree element representing the Text Node\n */\nconst TextNode = (value) => {\n  const vTree = createElement('#text', [], []);\n  vTree.nodeValue = value;\n  return vTree;\n};\n\n/**\n * HTMLElement, which contains a set of children.\n *\n * Note: this is a minimalist implementation, no complete tree structure\n * provided (no parentNode, nextSibling, previousSibling etc).\n *\n * @param {String} nodeName - DOM Node name\n * @param {Object} rawAttrs - DOM Node Attributes\n * @param {Object} supplemental - Interpolated data from a tagged template\n * @return {Object} vTree\n */\nconst HTMLElement = (nodeName, rawAttrs, supplemental) => {\n  const vTree = createElement(nodeName, [], []);\n\n  for (let match; match = attrEx.exec(rawAttrs || ''); ) {\n    let name = match[1];\n    let value = match[6] || match[5] || match[4] || match[1];\n    let attr = createAttribute(name, value);\n\n    if (attr.value === TOKEN) {\n      attr.value = supplemental.props.shift();\n    }\n\n    // If a key attribute is found attach directly to the vTree.\n    if (attr.name === 'key') {\n      vTree.key = attr.value;\n    }\n\n    // Look for empty attributes.\n    if (match[6] === '\"\"') { attr.value = ''; }\n\n    vTree.attributes.push(attr);\n  }\n\n  return vTree;\n};\n\n/**\n * Parses HTML and returns a root element\n *\n * @param {String} html - String of HTML markup to parse into a Virtual Tree\n * @param {Object} supplemental - Dynamic interpolated data values\n * @param {Object} options - Contains options like silencing warnings\n * @return {Object} - Parsed Virtual Tree Element\n */\nexport function parse(html, supplemental, options = {}) {\n  const root = HTMLElement('#document-fragment');\n  const stack = [root];\n  var currentParent = root;\n  var lastTextPos = -1;\n\n  // If there are no HTML elements, treat the passed in html as a single\n  // text node.\n  if (html.indexOf('<') === -1 && html) {\n    interpolateDynamicBits(currentParent, html, supplemental);\n    return root;\n  }\n\n  // Look through the HTML markup for valid tags.\n  for (let match, text; match = tagEx.exec(html); ) {\n    if (lastTextPos > -1) {\n      if (lastTextPos + match[0].length < tagEx.lastIndex) {\n        // if has content\n        text = html.slice(\n          lastTextPos, tagEx.lastIndex - match[0].length\n        );\n\n        interpolateDynamicBits(currentParent, text, supplemental);\n      }\n    }\n\n    let matchOffset = tagEx.lastIndex - match[0].length;\n\n    if (lastTextPos === -1 && matchOffset > 0) {\n      let string = html.slice(0, matchOffset);\n\n      if (string && string.trim() && !doctypeEx.exec(string)) {\n        interpolateDynamicBits(currentParent, string, supplemental);\n      }\n    }\n\n    lastTextPos = tagEx.lastIndex;\n\n    // This is a comment.\n    if (match[0][1] === '!') {\n      continue;\n    }\n\n    if (!match[1]) {\n      // not </ tags\n      let attrs = {};\n\n      if (!match[4] && kElementsClosedByOpening[currentParent.rawNodeName]) {\n        if (kElementsClosedByOpening[currentParent.rawNodeName][match[2]]) {\n          stack.pop();\n          currentParent = stack[stack.length - 1];\n        }\n      }\n\n      currentParent = currentParent.childNodes[\n        currentParent.childNodes.push(\n          HTMLElement(match[2], match[3], supplemental)\n        ) - 1\n      ];\n\n      stack.push(currentParent);\n\n      if (blockText.has(match[2])) {\n        // A little test to find next </script> or </style> ...\n        let closeMarkup = '</' + match[2] + '>';\n        let index = html.indexOf(closeMarkup, tagEx.lastIndex);\n        let length = match[2].length;\n\n        if (index === -1) {\n          lastTextPos = tagEx.lastIndex = html.length + 1;\n        }\n        else {\n          lastTextPos = index + closeMarkup.length;\n          tagEx.lastIndex = lastTextPos;\n          match[1] = true;\n        }\n\n        let newText = html.slice(match.index + match[0].length, index);\n        interpolateDynamicBits(currentParent, newText.trim(), supplemental);\n      }\n    }\n\n    if (match[1] || match[4] || selfClosing.has(match[2])) {\n      if (match[2] !== currentParent.rawNodeName && options.strict) {\n        const nodeName = currentParent.rawNodeName;\n\n        // Find a subset of the markup passed in to validate.\n        const markup = html.slice(\n          tagEx.lastIndex - match[0].length\n        ).split('\\n').slice(0, 3);\n\n        // Position the caret next to the first non-whitespace character.\n        const caret = Array(spaceEx.exec(markup[0]).index).join(' ') + '^';\n\n        // Craft the warning message and inject it into the markup.\n        markup.splice(1, 0, `${caret}\nPossibly invalid markup. Saw ${match[2]}, expected ${nodeName}...\n        `);\n\n        // Throw an error message if the markup isn't what we expected.\n        throw new Error(`${markup.join('\\n')}`);\n      }\n\n      // </ or /> or <br> etc.\n      while (currentParent) {\n        if (currentParent.rawNodeName == match[2]) {\n          stack.pop();\n          currentParent = stack[stack.length - 1];\n\n          break;\n        }\n        else {\n          const tag = kElementsClosedByClosing[currentParent.rawNodeName];\n\n          // Trying to close current tag, and move on\n          if (tag) {\n\n            if (tag[match[2]]) {\n              stack.pop();\n              currentParent = stack[stack.length - 1];\n\n              continue;\n            }\n          }\n\n          // Use aggressive strategy to handle unmatching markups.\n          break;\n        }\n      }\n    }\n  }\n\n  // Find any last remaining text after the parsing completes over tags.\n  const remainingText = html.slice(lastTextPos === -1 ? 0 : lastTextPos).trim();\n\n  // If the text exists and isn't just whitespace, push into a new TextNode.\n  interpolateDynamicBits(currentParent, remainingText, supplemental);\n\n  // This is an entire document, so only allow the HTML children to be\n  // body or head.\n  if (root.childNodes.length && root.childNodes[0].nodeName === 'html') {\n    // Store elements from before body end and after body end.\n    let head = { before: [], after: [] };\n    let body = { after: [] };\n    let beforeHead = true;\n    let beforeBody = true;\n    let HTML = root.childNodes[0];\n\n    // Iterate the children and store elements in the proper array for\n    // later concat, replace the current childNodes with this new array.\n    HTML.childNodes = HTML.childNodes.filter(function(el) {\n      // If either body or head, allow as a valid element.\n      if (el.nodeName === 'body' || el.nodeName === 'head') {\n        if (el.nodeName === 'head') {\n          beforeHead = false;\n        }\n\n        if (el.nodeName === 'body') {\n          beforeBody = false;\n        }\n\n        return true;\n      }\n      // Not a valid nested HTML tag element, move to respective container.\n      else if (el.nodeType === 1) {\n        if (beforeHead && beforeBody) {\n          head.before.push(el);\n        }\n        else if (!beforeHead && beforeBody) {\n          head.after.push(el);\n        }\n        else if (!beforeBody) {\n          body.after.push(el);\n        }\n      }\n    });\n\n    // Ensure the first element is the HEAD tag.\n    if (!HTML.childNodes[0] || HTML.childNodes[0].nodeName !== 'head') {\n      let headInstance = pools.elementObject.get();\n      headInstance.nodeName = 'head';\n      headInstance.childNodes.length = 0;\n      headInstance.attributes.length = 0;\n\n      let existing = headInstance.childNodes;\n      existing.unshift.apply(existing, head.before);\n      existing.push.apply(existing, head.after);\n\n      HTML.childNodes.unshift(headInstance);\n    }\n    else {\n      let existing = HTML.childNodes[0].childNodes;\n      existing.unshift.apply(existing, head.before);\n      existing.push.apply(existing, head.after);\n    }\n\n    // Ensure the second element is the body tag.\n    if (!HTML.childNodes[1] || HTML.childNodes[1].nodeName !== 'body') {\n      let bodyInstance = pools.elementObject.get();\n      bodyInstance.nodeName = 'body';\n      bodyInstance.childNodes.length = 0;\n      bodyInstance.attributes.length = 0;\n\n      let existing = bodyInstance.childNodes;\n      existing.push.apply(existing, body.after);\n\n      HTML.childNodes.push(bodyInstance);\n    }\n    else {\n      let existing = HTML.childNodes[1].childNodes;\n      existing.push.apply(existing, body.after);\n    }\n  }\n\n  return root;\n}\n"]}